#!/usr/bin/env python3

# Determine precision by assuming the operands are precise down to the unit.

from argparse import ArgumentParser
from fractions import Fraction
from itertools import count
import math
import sys

ap = ArgumentParser()
ap.add_argument('a', type=int, help='Numerator')
ap.add_argument('b', type=int, help='Denominator')


def roundG(x, precision):
    return '{:.{}g}'.format(x, precision)


def enoughDigits(a, b, q):
    """Show only enough digits to be unique to the numerator."""
    for precision in count(1):
        qString = roundG(q, precision)
        if a == round(float(qString) * b):
            return qString


def main(argv):
    args = ap.parse_args()

    a = args.a
    b = args.b
    q = a / b

    print(
        roundG(
            q,
            math.ceil(math.log10(q)) - math.floor(math.log10(q / min(a, b))),
        ),
    )

    # Show as rational.
    print(Fraction(a, b))

    print(enoughDigits(a, b, q))

    # Show the simplest fraction that results in the right a when scaled up.
    testA = 0
    smallB = 0
    while testA != a:
        smallB += 1
        smallA = round(smallB * q)
        testA = round(smallA * b / smallB)
        print(testA, end=' ')
    print()
    print('{}/{}'.format(smallA, smallB))


if __name__ == '__main__':
    main(sys.argv[1:])
