#!/usr/bin/env python3

# Determine precision by assuming the operands are precise down to the unit.

from argparse import ArgumentParser
from fractions import Fraction
import math
import sys


def roundG(x, precision):
    return '{:.{}g}'.format(x, precision)


ap = ArgumentParser()
ap.add_argument('a', type=int, help='Numerator')
ap.add_argument('b', type=int, help='Denominator')


def main(argv):
    args = ap.parse_args()

    a = args.a
    b = args.b
    q = a / b

    print(roundG(q, math.ceil(math.log10(q)) - math.floor(math.log10(q / min(a, b)))))

    # Show only enough digits to be unique to the numerator.
    testA = 0
    precision = 1
    while testA != a:
        qString = roundG(q, precision)
        testA = round(float(qString) * b)
        precision += 1
    print(qString)

    # Show as rational.
    print(Fraction(a, b))

    # Show the simplest fraction that results in the right a when scaled up.
    testA = 0
    smallB = 0
    while testA != a:
        smallB += 1
        smallA = round(smallB * q)
        testA = round(smallA * b / smallB)
        print(testA, end=' ')
    print()
    print('{}/{}'.format(smallA, smallB))


if __name__ == '__main__':
    main(sys.argv[1:])
